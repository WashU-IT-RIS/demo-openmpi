#!/bin/bash

# Copyright International Business Machine Corporation, 2012-2013

# This information contains sample application programs in source language, which
# illustrates programming techniques on various operating platforms. You may copy,
# modify, and distribute these sample programs in any form without payment to IBM,
# for the purposes of developing, using, marketing or distributing application
# programs conforming to the application programming interface for the operating
# platform for which the sample programs are written. These examples have not been
# thoroughly tested under all conditions. IBM, therefore, cannot guarantee or
# imply reliability, serviceability, or function of these programs. The sample
# programs are provided "AS IS", without warranty of any kind. IBM shall not be
# liable for any damages arising out of your use of the sample programs.

# Each copy or any portion of these sample programs or any derivative work, must
# include a copyright notice as follows:

# (C) Copyright IBM Corp. 2012-2013.

# This dynamic ELIM example determines the number of MIC devices
# installed on a host and collects the following metrics for each 
# device using the Intel MPSS 'micsmc' tool:
# CPU Temperature
# Core Frequency
# Total Power
# Free Memory
# CPU Utilization
# Number of cores per card

# Global variables
# If micsmc, micctrl are in a different location, adjust accordingly.
  ELIM_MICSMC="/opt/intel/mic/bin/micsmc"
  ELIM_MICCTRL="/usr/sbin/micctrl"
  ELIM_LOG_FILE=$LSF_LOGDIR/$0.$$
  SLEEP_INTERVAL=60
  let ELIM_METRICS_NUM=6

  # 'tmpfile' will store output from Intel MPSS 'micsmc' command.  
  tmpfile=$(mktemp -q)

  # 'tmpfile2' will store output from Intel MPSS 'micctrl' command.  
  tmpfile2=$(mktemp -q)

# Functions
function elim_exit ()
{
 trap '' 1 2 3 15
 # Cleanup of temp files.
 rm -f $tmpfile
 rm -f $tmpfile2
 exit 1
}

# Here we parse out data from the two tempor ary files (tmpfile, tmpfile2)
# which contain the output of the MPSS micctrl and micinfo commands
# respectively.  
function elim_parse ()
{  
  local idx=$1
  local tmp

  let x=1

  cputmp=$(grep "Cpu Temp:" $tmpfile | awk '{print $4}')
  corefreq=$(grep "Core Frequency:" $tmpfile | awk '{print $4}')
  totalpower=$(grep "Total Power:" $tmpfile | awk '{print $4}')
  freemem=$(grep "Free Memory:" $tmpfile | awk '{print $4}')  
  cpuuser=$(grep "Device Utilization:" $tmpfile | awk '{print substr($4,1,length($4)-2)}')
  cpusystem=$(grep "Device Utilization:" $tmpfile | awk '{print substr($6,1,length($6)-2)}')
  micstatus=$(cat $tmpfile2 | awk '{print $2}') 
  miccores=$(grep "Number of Cores:" $tmpfile | awk '{print $5}')
 
  for ((i=0; i < $idx; i++)) {
    mic_status[i]="mic_status$i $(echo $micstatus | awk '{print $'$x'}')" 
    if [ "$(echo $micstatus | awk '{print $'$x'}')" != "online" ] 
        then
        ONLINE[i]=false
    else
        ONLINE[i]=true
    fi
    let x+=1
  }  

  # ONLINE is set to false when one or more of the KNC devices is not in 
  # "online" status.  In order for micsmc -a to function, KNC devices
  # must be in "online" status.  When ONLINE is false, we set all metrics
  # to zero. 
 
  let y=1
  for ((j=0; j < $idx; j++)) { 
      if [ ${ONLINE[j]} = "true" ] 
      then
          miccpu_temp[j]="mic_temp$j $(echo $cputmp | awk '{print $'$y'}')"
          miccore_freq[j]="mic_freq$j $(echo $corefreq | awk '{print $'$y'}')"
          mictotal_power[j]="mic_power$j $(echo $totalpower | awk '{print $'$y'}')"
          micfree_mem[j]="mic_freemem$j $(echo $freemem | awk '{print $'$y'}')"
          miccpu_user[j]="$(echo $cpuuser | awk '{print $'$y'}')"
          miccpu_system[j]="$(echo $cpusystem | awk '{print $'$y'}')"
          # Xeon Phi CPU utilization is crudely calculated as the sum of
          # user and system.  
          sum=`echo "${miccpu_user[j]}+${miccpu_system[j]}" | bc`
          miccpu_util[j]="mic_util$j $sum"
          micnum_cores[j]="mic_ncores$j $(echo $miccores | awk '{print $'$y'}')"
          y=`expr $y + 1`
      else
          miccore_freq[j]="mic_freq$j 0"
          miccpu_temp[j]="mic_temp$j 0"
          mictotal_power[j]="mic_power$j 0"
          micfree_mem[j]="mic_freemem$j 0"
          miccpu_util[j]="mic_util$j 0"
          micnum_cores[j]="mic_ncores$j 0"
      fi
  }

  rm -f $tmpfile
  rm -f $tmpfile2

}


function elim_get_total_devices_num ()
{
  # call micsmc and store output in 'tmpfile' 
  `$ELIM_MICSMC -a  &> $tmpfile` 
  if [ $? -ne 0 ]; then
    echo "[Error]: $ELIM_MICSMC failed." > $ELIM_LOG_FILE
    #return 1
  fi 

  # call micctrl and store output in 'tmpfile2' 
  `$ELIM_MICCTRL -w &> $tmpfile2` 
  if [ $? -ne 0 ]; then
    echo "[Error]: $ELIM_MICCTRL failed." > $ELIM_LOG_FILE
    #return 1
  fi

  let MIC_DEVICE_NUM_TOTAL=$(cat $tmpfile2 | wc -l) 

  if [ $? -ne 0 ]; then
    echo "[Error]: get_total_devices_num: Cannot get total number of devices." >$ELIM_LOG_FILE
    return 1
  fi 
  return 0
}

function elim_print_output_for_lim ()
{
  local resources=
  if [ -z $MIC_DEVICE_NUM_TOTAL ]; then
    return 1
  fi
  for (( i=0; i<$MIC_DEVICE_NUM_TOTAL; i++)) {
      resources="$resources ${miccpu_temp[i]} ${miccore_freq[i]} ${mictotal_power[i]} ${micfree_mem[i]} ${miccpu_util[i]} ${micnum_cores[i]}" 
  }

  # For each MIC, we collect ELIM_METRICS_NUM of metrics.  
  local total_resources=$(($MIC_DEVICE_NUM_TOTAL*$ELIM_METRICS_NUM))
  echo "$total_resources $resources"
}

# Main 

trap elim_exit 1 2 3 15

# Global arrays for resources.
declare -a mic_status miccpu_temp miccore_freq mictotal_power micfree_mem miccpu_util miccpu_user miccpu_system micnum_cores

# Check if MPSS is installed.
if [ ! -x $ELIM_MICSMC -o ! -x $ELIM_MICCTRL ]; then
    echo "Error: Intel MIC control commands do not exist, exiting." >$ELIM_LOG_FILE
    rm -f $tmpfile
    rm -f $tmpfile2
    exit 1
fi

while [ true ] 
do

  # Get total number of MIC devices
  elim_get_total_devices_num
  if [ $? -ne 0 ]; then
    continue
  fi
  
  # Get resources for each device
  elim_parse $MIC_DEVICE_NUM_TOTAL
  # echo "MIC_DEVICE_NUM_TOTAL = $MIC_DEVICE_NUM_TOTAL"

  # Prepare output for lim
  elim_print_output_for_lim

  sleep $SLEEP_INTERVAL 

done
