README for Example External Scheduler and FCFS Plugins 
IBM Spectrum LSF Version 10.1

=========================
CONTENTS
=========================
1. In this Directory
2. About External Scheduler Plugins
3. Writing an External Scheduler Plugin
4. Building an External Scheduler Plugin
5. Using an External Scheduler Plugin
6. Debugging an External Scheduler Plugin
7. About the FCFS plugin
8. Copyright

=========================
1. In this Directory
=========================

README                                 this file.
Makefile        
matchexample.c                         example for Match 
allocexample.c                         example for Allocation 
sch.mod.fcfs.c                         source code of FCFS plugin
myplugin.c                             example plugin using extsched_* API

Notes: See $LSF_INCLUDEDIR/lssched.h for the usage of LSF's external 
       scheduler plugin API.
       
       See "Using the IBM Spectrum LSF SDK" for more information about writing
       an external scheduler plugin.


=========================
2. About External Scheduler Plugins
=========================

The default scheduler plugin modules provided by LSF may not satisfy all the 
particular scheduling policies you need. You can use the LSF scheduler plugin API 
to customize existing scheduling policies or implement new ones that can operate 
with existing LSF scheduler plugin modules.

o  Certain scheduling policies can be implemented based on the specific   
    requirements of your site.
o  Customized policies can be incorporated with other LSF features to provide 
    seamless behavior. Your custom scheduling policy can influence, modify, or 
    override LSF scheduling decisions.
o  Your plugin can take advantage of the load and host information already 
    maintained by LSF.
o  The scheduler plugin architecture is fully external and modular; new scheduling 
    policies can be prototyped and deployed without having to change the compiled 
    code of LSF.


=========================
3. Writing an External Scheduler Plugin
=========================
Customized policies can be applied into two places of a scheduling cycle:
Match Stage and Allocation Stage.

------------------------
3.1 Match Stage
------------------------
    In Match stage, scheduler prepares candidate hosts for jobs. All jobs with
    the same resource requirement share the same candidate hosts(peer jobs).
    At this stage, the plugin can decide which host is eligible for future 
    consideration. If the host is not eligible for the job's use, it
    can be removed from the candidate host list, and at same time the plugin 
    can associate a pending reason with the removed host, which will be shown 
    by the bjobs command.
    
    In addition, the plugin at this stage can decide the order of the candidate
    host; i.e., which host should be considered first in future.

    The plugin in this stage provides two functions:
         1. Match(): filter on candidate hosts
         2. Sort():  order on candidate hosts
    
------------------------
3.2 Allocation Stage
------------------------
    In Allocation Stage, scheduler makes allocation decisions for each job,
    it assigns host slot, mem, and other resources to the job. At same time, it
    checks if the allocation satisfies all constraints defined in 
    configuration, such as queue slot limit, deadline for the job, etc.

    The plugin at this stage can modify allocation decisions made by
    LSF module.
 
    For the time being, there are some limitations about allocation 
    modification: 
    o  The external plugin is only allowed to change the host
       slot distribution; i.e., reduce/increase the slot usage on certain
       host, add more hosts to the allocation. Other resource usage 
       modification is not supported now.
    o  The external plugin is not allowed to remove a host from 
       an allocation.
    o  The external plugin cannot change an allocation with reservation.
       (alloc type: SCH_MOD_DECISION_RESERVE).

------------------------
3.3 Plugin main Routine: sched_init()
------------------------
    Every plugin needs to provide sched_init(), and it is the first function
    that is called after plugin is loaded by scheduler framework.
    In this function, several callback functions need to be registered to 
    scheduler framework, and these callback functions provide the 
    functionality for Match and Allocation stages.

       For Match stage:
           create handler for resource requirement processing, 
           and register it to scheduler framework. (For detail, see below)

       For Allocation Stage: 
           register allocation callback AllocatorFn(). (For detail, see below)

------------------------
3.4 Implementing Match Stage
------------------------
    This section provides details for writing code for Match Stage.
 
------------------------
3.4.1 Input and Output of Match Stage
    The input/output of this stage are candHostGroupList and 
    pendingReasonTable. 
    
    Candidate hosts are divided into several groups, and job can only use
    hosts from one of candHostGroup in the candHostGroupList.

    The Plugin filters the candHostGroups in candHostGroupList, 
    set the pending reason for ineligible hosts  to PendingReasonTable,
    and remove them from the group. The plugin can also change the host order
    in a group.(First host has highest preference.)

------------------------
3.4.2 Invocation
    Each plugin does matching and sorting based on certain resource
    Requirement; i.e., it decides which host is qualified and which should be first 
    based on certain kind of resource requirement. We organize the Match() and 
    Sort() into the handler of the certain resource requirement.
    Usually external plugin handler only handles external resource
    requirement(string) which is specified through bsub command using
    -extsched option. 

    After the handler is created, all that plugin needs to do is to register it
    to scheduler framework. Then it is the scheduler framework's responsibility
    to call each handler doing Match and Sort and handling each specific 
    resource requirement.

    When the plugin registers the handler, a handler ID needs to be
    associated with the handler. This handler ID differentiates this handler
    with other handlers. 

    Together with Match() and Sort(), there are other two handler functions:
        New(): getting the user-specific resource requirements string, parse
               it, create the handler-specific-data, and finally attach the
               data to related resource requirement.
        Free(): freeing the handler-specific data when not needed.

    See lssched.h for details.
    

------------------------
3.4.3 Implementation Steps for Match Stage
    (See matchexample.c for details)

3.4.3.1 Step 1. 
    Define handler ID,  handler-specific-data, and user
    specific pending reason.

    handlerID must be a integer between 100 and 199. (other numbers are 
    reserved for LSF uses.)

    New() function need to parse the external resource requirement string,
    and store the parsed resource to handler-specific-data.

    Handler-specific-data is actually a container used to store any data 
    which is needed by handler.

    If plugin needs to set user specific pending reasons, a pending reason ID
    need to be defined. (See lsb_reason_set() in lssched.h.)

3.4.3.2 Step 2.
    Implement handler functions: New(), Free(), Match(), and Sort().

    New():
       1. Get external resource requirement message.(lsb_resreq_getextresreq())
       2. Find my message, and parse it.
       3. Create handler-specific-data, and store parsing result in it.
       4. Create a key, (In example, just use external message as a key).
       5. Attach the handler-specific-data. (lsb_resreq_setobject()).

    Free():
       1. Free whatever in handler-specific-data.

    Match(): (handler-specific-data is passed in)
       1. Go through all candidate host groups.(lsb_cand_getnextgroup())
       2. Look at candidate host in each group. If a host is not eligible,
          remove it from group and set pending reason.
          (lsb_cand_removehost(), lsb_reason_set())

    Sort(): (handler-specific-data is passed in)
       1. Go through all candidate host groups.(lsb_cand_getnextgroup())
       2. Sort the candidate hosts in the group.

3.4.3.3 Step 3.
    Implement sched_init(). This function is the plugin init function, which
    will be called when the plugin is loaded.
    
       1. Create handler, and register it to scheduler framework.
          (lsb_resreq_registerhandler).

------------------------
3.5 Implementing Allocation Stage
------------------------
    This section provides details for writing code for Allocation Stage.

------------------------
3.5.1 Input and Output of Allocation Stage
    INPUT:
        job: current job we are making allocation for. 
        candHostGroupList: (see section 3.4.1)
        pendingReasonTable: (see section 3.4.1)

    INPUT/OUTPUT:
        alloc: LSF allocation decision is passed in, and plugin will modify
        it, and make its own allocation decision on top of it.

------------------------
3.5.2 Invocation
    At allocation stage the plugin must provide a callback function
    (AllocatorFn), which adjusts allocation decisions made by LSF. 
    This function must be registered to scheduler framework, and it is
    scheduler framework's responsibility to call it after LSF makes a 
    decision for the job.

    In addition to AllocatorFn(), plugin may also need to provide New() function
    in handler for the user-specific resource criteria, if there is one. 
    (See section 3.4.2 for details)
    If there is no such user specific resource requirement(AllocatorFn() 
    is applied to all jobs), we do not need to do that.

------------------------
3.5.3 Implementation Steps for Allocation Stage
    (See allocexample.c for details)

3.5.3.1 Step1. (optional)
    Define handler ID, if a handler for external resource requirement is
    needed. 

3.5.3.2 Step2. (optional)
    Implement New() function in the handler for the external resource 
    requirement.

3.5.3.3 Step3.
    Implement callback AllocatorFn(). 
       1. Check if the allocation has the type of SCH_MOD_DECISION_DISPATCH.
          if not, just return. (lsb_alloc_type())
       2. (Optional) get external message, and decide whether to continue.
          (lsb_job_getextresreq()).
       3. Get current slot distribution in allocation, and availability 
          information for all candidate hosts. (lsb_alloc_gethostslot())
       4. Modify the allocation basing on certain algorithm.
          (lsb_alloc_modify())
          
          You should use lsb_alloc_modify() gradually, instead of 
          making big changes at one time, because lsb_alloc_modify() may
          return FALSE due to conflict with other scheduling policies, 
          such as user slot limit on host. (See sch.mod.allocexample.c, where
          slots are adjusted in small steps.)

3.5.3.4 Step4.
    Implement sched_init(). This function is the plugin init function, which
    will be called when the plugin is loaded.

       1. (Optional) create handler for resource requirement processing, 
          and register it to scheduler framework.
          (lsb_resreq_registerhandler()).

       2. Register allocation callback AllocatorFn(). 
          (lsb_alloc_registerallocator())


=========================
4. Building External Scheduler Plugin
=========================
Step1. Set INCDIR and LIBDIR in the Makefile to point to the appropriate
       directories for the LSF include files and libraries respectively.
Step2. Creat a Make.def for the platform on which you want to built examples.
       The Make.def file should locate in the misc directory( the same level
       of Make.misc). (Make.misc is in $LSF_MISC)
     
       All Make.def templates for each platforms are in config directory.
       For example, if you want to run examples on Solaris2.6, you can just
       use following command to create Make.def.
       ln -s config/Make.def.sparc-sol2 Make.def
       You can also change the file, if it is necessary.
Step3. enter "make" in current directory.


=========================
5. Using External Scheduler Plugin
=========================
    (Use sch.mod.matchexample.c as a example)
    
    1. Copy the newly built schmod_matchexample.so to  $LSF_LIBDIR
       It is defined in cshrc.lsf, profile.lsf.(in 4.1, defined in lsf.conf)
    2. Configure the plugin in lsb.modules
       add following line after all LSF modules:
       
       schmod_matchexample     ()           ()

    3. Run badmin mbdrestart to restart LSF
    4. Submit a job. If external message is needed, bsub with option -extsched.
       for example:  
       bsub -n 2 -extsched "EXAMPLE_MATCH_OPTIONS=hostA" -R "type==any" sleep 1000
    5. Use bjobs to look at external message, and customized pending reason. 
       For example:

./bjobs -lp

Job <224>, User <user1>, Project <default>, Status <PEND>, Queue <short>, Job Pri
                     ority <500>, Command <sleep 1000>
Thu Nov 29 15:08:05: Submitted from host <hostA> with hold, CWD <$HOME/LSF/,
                     Requested Resources <type==any>;
 PENDING REASONS:
 Load information unavailable: hostB, hostC, hostD, hostE;
 Closed by LSF administrator: hostF, hostG;
 Customized pending reason number 20002: hostA;

 SCHEDULING PARAMETERS:
           r15s   r1m  r15m   ut      pg    io   ls    it    tmp    swp    mem
 loadSched   -     -     -     -       -     -    -     -     -      -      -  
 loadStop    -     -     -     -       -     -    -     -     -      -      -  

          total_jobs mbd_size 
 loadSched        -        -  
 loadStop         -        -  

 EXTERNAL MESSAGES:
 MSG_ID FROM       POST_TIME      MESSAGE                             ATTACHMENT 
 0          -             -                        -                      -     
 1      user1      Nov 29 15:08   EXAMPLE_MATCH_OPTIONS=hostA            N     
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

=========================
6. Debugging an External Scheduler Plugin
=========================
    1) mbschd.log.hostA will show which plugins is successfully loaded. 
       If loading is failed, the error message is also logged.
    2) Use a debug tool to debug plugin, such gdb, dbx, etc.
       Attach to mbschd, and set breakpoint in the functions of plugin.
    
 
=============================
7. About the FCFS plugin
=============================
    The FCFS plugin, schmod_fcfs.so, implements the FCFS (First Come First Served)
    job scheduling policy, which is the default policy for all LSF queues. It 
    will be loaded automatically without any license required, like 
    schmod_default.so.

    sch.mod.fcfs.c is the source code. It can be treated exactly as an external
    plugin example. Users can change LSF's FCFS behavior by modifying sch.mod.fcfs.c 
    and building a new schmod_fcfs.so.

    The previous two examples are related to LSF scheduler's match stage and 
    allocation stage. The FCFS plugin is a part of LSF scheduler's order 
    stage, which is between match stage and allocation stage.

7.1 Order Stage and Order Functions
    The order stage of job scheduling decides the order of job dispatch. LSF 
    job scheduling is based on either queue or host partiton. FCFS is only 
    applied to queue-based job scheduling.

    Before scheduling jobs for a queue, LSF scheduler must register an order 
    function for the queue. Up to now, there are two order functions provied 
    by LSF, FCFS order function and Fairshare order function. Users can make
    the choice through queue level configuration.

------------------------
7.2 Implementing FCFS plugin
------------------------

------------------------
7.2.1 FCFS order function - decideOrder4FCFS()
    decideOrder4FCFS() is a call back function.

7.2.1.1 Input and Output of decideOrder4FCFS()
    INPUT:
        queueName: The queue which the job list belongs to.                   
        jobList:   The ready job list of the queue.

    OUTPUT:
        Return the job with the highest FCFS priority if jobList is not NULL;
        Otherwise return NULL.

7.2.1.2 FCFS Priority - compareFunc4FCFS()
    The job with higher job priority, which can be defined by bsub -sp, has 
    higher FCFS priority. If two jobs have the same job priority, then the one 
    with smaller sequence number has higher FCFS priority. 

    In sch.mod.fcfs.c, compareFunc4FCFS() is used to decide jobs' FCFS priority.

7.2.1.3 Job Sequence Number
    A job sequence number is an unsigned integer number used by LSF 
    scheduler internally. Normally, a job submitted ealier will have a smaller 
    sequence number. 

    In most cases, job submission time can be used to replace the sequence 
    number unless btop/bbot or requeue actions are applied to jobs. As a job's
    sequence number will be adjusted accordingly in such situations, FCFS 
    plugin uses it directly.

------------------------
7.2.2 Register the FCFS order function
    At initialization stage, FCFS plugin calls 
    lsb_order_registerOrderFn4AllQueues() 
    to register decideOrder4FCFS() for all the queues as default policy. 
    
    See:
        -  sched_init() in sch.mod.fcfs.c
        -  lsb_order_registerOrderFn4AllQueues() in lssched.h.

------------------------
7.3 Building the FCFS plugin
------------------------
    See 4. "Building External Scheduler Plugin" in this README.

------------------------
7.4 Using the FCFS plugin
------------------------
    1) Copy the newly built schmod_fcfs.so to $LSF_LIBDIR
       (defined in cshrc.lsf, profile.lsf).
    2) Run badmin mbdrestart to restart LSF.

    You also can configure schmod_fcfs in lsb.modules, but LSF will load it 
    automatically if it is not specified in lsb.modules The order of schmod_fcfs 
    is not important.
    
    Begin PluginModule
    SCH_PLUGIN                      RB_PLUGIN                    SCH_DISABLE_PHASES
    schmod_default                  ()                                   ()
    schmod_fcfs                     ()                                   ()     
    ...
    End PluginModule 

=========================
8. Copyright
=========================
Copyright IBM Corp. 1992, 2016. All rights reserved.
US Government Users Restricted Rights - Use, duplication or disclosure
restricted by GSA ADP Schedule Contract with IBM Corp.

Although the information in this document has been carefully reviewed, 
IBM Corporation does not warrant it to be free of errors or omissions. 
IBM Corporation reserves the right to make corrections, updates, 
revisions or changes to the information in this 
document.

UNLESS OTHERWISE EXPRESSLY STATED BY IBM CORPORATION, THE PROGRAM DESCRIBED IN 
THIS DOCUMENT IS PROVIDED "AS IS" AND WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO 
EVENT WILL IBM CORPORATION BE LIABLE TO ANYONE FOR SPECIAL, 
COLLATERAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING WITHOUT 
LIMITATION ANY LOST PROFITS, DATA OR SAVINGS, ARISING OUT OF THE USE OF 
OR INABILITY TO USE THIS PROGRAM.

LSF is a registered trademark of IBM Corporation in the 
United States and in other jurisdictions.

UNIX is a registered trademark of The Open Group.

Other products or services mentioned in this document are the trademarks 
of their respective owners.

==============================
END of README for Example External Scheduler Plugins
Last update: Wednesday January 12 2005
==============================
