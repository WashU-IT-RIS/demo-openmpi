#!/usr/bin/perl -w

use strict;
use warnings;
use Time::gmtime;
use Time::HiRes qw(usleep gettimeofday);
#--------------------------------------------------------------------
# Constants
#--------------------------------------------------------------------
# Check interval in seconds
use constant CHECK_INTERVAL => 5;

# Floating average interval in seconds. This value should be evenly devided by the CHECK_INTERVAL
use constant FLOATING_AVG_INTERVAL => 30;

# Volume to include. If no volume is configured, no volume will be included
use constant VOLUMES => ["gpfs01", "gpfs02"];

# Max inbound in GB for each volume
use constant MAX_INBOUND => {
	"gpfs01" => 150,
	"gpfs02" => 150
};

# Max outbound for each volume
use constant MAX_OUTBOUND => {
	"gpfs01" => 150,
	"gpfs02" => 150
};

# Decimal digits
use constant DECIMAL_DIGITS => 4;

#--------------------------------------------------------------------
# Constants for internal use only
#--------------------------------------------------------------------
# Command-line to get the lsload
use constant LSLOAD_CMD => "lsload -l";
#use constant LSLOAD_CMD => "cat ./lsload.dat";

#--------------------------------------------------------------------
# Trim function to remove whitespace from the start and end of the string
#--------------------------------------------------------------------
sub trim {
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}


#--------------------------------------------------------------------
# Parse header
#--------------------------------------------------------------------
sub parseHeader {
	my $tokens = shift;
	my %header = ();
	my %volumes = ();
	my $idx = 0;
	my %volumeSet = ();

	# Convert the VOLUMES list to a hash table
	foreach (@{+VOLUMES}) {
		$volumeSet{$_} = 1;
	}

	# For each token in the header
	foreach (@{$tokens}) {
		my $resName = trim($_);
		if ($resName =~ m/gbytes(in|out)_(.*)/ig) {
			# Volume level value. Check if the volume is defined in the VOLUMES list
			my $gpfsName = $2;
			if ($volumeSet{$gpfsName}) {
				$volumes{$gpfsName} = 1;
				$header{$resName} = $idx;
			}
		}
		$idx++;
	}

	return (\%header, \%volumes);
}

#--------------------------------------------------------------------
# Calculate metrics
#--------------------------------------------------------------------
sub getLsload {

	my $cmd = LSLOAD_CMD;
	# Call the command line and get outputs of lsload -l
	#open(my $fh, "-|", $cmd) or return {};
	my @outputs = `$cmd`;
	if ($? >> 8 != 0) {
		return {};	
	}

	# Row number
	my $firstRow = 1;

	# Dictionary for column_name:index parsed from header
	my $header = {};
	# Volumes to monitor parsed from resource name
	my $volumes = {};
	# Dictionary for bytesin_volx, bytesout_volx
	my %values = ();

	# Indicate if this is a valid sampling
	my $validSampling = 0;

	# Parse each line
	foreach (@outputs) {
		# Trim the string
		my $line = trim($_);

		# Skip empty line
		next if ("" eq $line);
		
		# Split the current line
		my @tokens = split(" ", $line);
		next if (@tokens < 1);

		if ($firstRow == 1) {
			# Parse header of the lsload output
			($header, $volumes) = parseHeader(\@tokens);
			# Initialize the value map
			for (keys %$header) {
				$values{$_} = 0.0;
			}

			$firstRow = 0;
		}
		else {
			for (keys %$header) {
				my $idx = $header->{$_};
				if (@tokens > $idx && $tokens[$idx] =~ m/[0-9]+(\.[0-9]+)?/) {
					$values{$_} = $values{$_} + $tokens[$idx];
					$validSampling = 1;
				}
			}
		}
	}

	# If there is valid value for all rows, reset the values hash table
	#if ($validSampling == 0) {
		#%values = ();
	#}

	return (\%values, $volumes);
}


#--------------------------------------------------------------------
# Calculate availability
#--------------------------------------------------------------------
sub calcAvail {
	my ($values, $volumes) = @_;

	my $totalAvailIn = 0.0;
	my $totalAvailOut = 0.0;

	my %avails = ();

	# Do not calculate avail values, if there is no valid value in the %values hash table
	if (keys %$values == 0) {
		return \%avails;
	}

	# For each volume
	for (keys %$volumes) {
		my $maxAvailIn = ${+MAX_INBOUND}{$_};
		if (!$maxAvailIn) {
			print STDERR "MAX_INBOUND was not defined for the volume '$_'\n";
			next;
		}

		my $maxAvailOut = ${+MAX_OUTBOUND}{$_};
		if (!$maxAvailOut) {
			print STDERR "MAX_OUTBOUND was not defined for the volume '$_'\n";
			next;
		}
		
		my $inbound = $values->{"gbytesin_$_"};
		my $outbound = $values->{"gbytesout_$_"};

		# Available inbound for the current volume
		my $availIn = $maxAvailIn - $inbound;
		if ($availIn < 0) {
			$availIn = 0;
		}
		# Put the avaialbe inbound into the hash table
		$avails{"gtotalin_$_"} = $availIn;

		# Available outbound for the current volume
		my $availOut = $maxAvailOut - $outbound;
		if ($availOut < 0) {
			$availOut = 0;
		}
		# Put the avaialbe outbound into the hash table
		$avails{"gtotalout_$_"} = $availOut;

		$totalAvailIn += $availIn;
		$totalAvailOut += $availOut;
	}

	# Put the total avaialbe inbound into the hash table
	if (keys %avails > 0) {
		$avails{"gtotalin"} = $totalAvailIn;
		$avails{"gtotalout"} = $totalAvailOut;
	}

	return \%avails;
}

#--------------------------------------------------------------------
# Entry of the elim
#--------------------------------------------------------------------
sub _main {
        if ($ENV{'LSF_MASTER'} ne 'Y' && $ENV{'EGO_MASTER'} ne 'Y' ) {
	        exit $ENV{'ELIM_ABORT_VALUE'};
	}

	my $samplingTimeAdjustment = 0;

	my $resFormatter = "%s %s %." . DECIMAL_DIGITS . "f";
	while (1) {
		# Get the current microsecond
		my ($seconds, $fraction) = gettimeofday();
		my $startTime = $seconds * 1000000 + $fraction;

		# Get the current snapshot of lsload
		my ($values, $volumes) = getLsload();
		my $avails = calcAvail($values, $volumes);

		my $numRes = keys %$avails;
		# Got no resources
		if ($numRes > 0) {
			my $resResult = "$numRes";
			for (keys %$avails) {
				$resResult = sprintf($resFormatter, $resResult, $_, $avails->{$_});
			}

			# Output the resource string to stdout
			print $resResult;
			print "\n";
		}

		# Get the current microsecond
		($seconds, $fraction) = gettimeofday();
		my $endTime = $seconds * 1000000 + $fraction;

		my $timeToSleep = CHECK_INTERVAL * 1000000 - ($endTime - $startTime) - $samplingTimeAdjustment;
		if ($timeToSleep > 0) {
			usleep($timeToSleep);
		}
	}
}

# Set an auto-flush for both STDOUT and STDERR
select(STDERR);
$| = 1;
select(STDOUT);
$| = 1;

# Entering the main entry
_main();

