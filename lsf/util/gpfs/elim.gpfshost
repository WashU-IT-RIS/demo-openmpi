#!/usr/bin/perl -w

use strict;
use warnings;
use Time::gmtime;
use Time::HiRes qw(usleep gettimeofday);

#--------------------------------------------------------------------
# Constants
#--------------------------------------------------------------------
# Check interval in seconds
use constant CHECK_INTERVAL => 5;

# Floating average interval in seconds. This value should be evenly devided by the CHECK_INTERVAL
use constant FLOATING_AVG_INTERVAL => 30;

# Volume to include. If no volume is configured, no volume will be included
use constant VOLUMES => ["gpfs01", "gpfs02"];

# Full path of the command-line to get the GPFS statistics
use constant MMPMON_PATH => "/usr/lpp/mmfs/bin/mmpmon";
#use constant MMPMON_PATH => "cat";

# Decimal digits
use constant DECIMAL_DIGITS => 4;

#--------------------------------------------------------------------
# Constants for internal use only
#--------------------------------------------------------------------
# Index of the GPFS name
use constant IDX_GPFS_NAME => 14;

# Starting index of metrics
use constant STARTING_IDX_METRICS => 17;

# Key for sampling time
use constant SAMPLING_TIME => "SAMPLING_TIME";

# Key for sampling interval
use constant SAMPLING_INTERVAL => "SAMPLING_INTERVAL";

# Max sampling interval to keep
use constant MAX_SAMPLING_INTERVAL => (FLOATING_AVG_INTERVAL - CHECK_INTERVAL / 2);

#--------------------------------------------------------------------
# Glogal variables
#--------------------------------------------------------------------
# Hash for volume to monitor
our %gVolumeSet = ();

#--------------------------------------------------------------------
# Trim function to remove whitespace from the start and end of the string
#--------------------------------------------------------------------
sub trim {
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}

#--------------------------------------------------------------------
# Calculate metrics
#--------------------------------------------------------------------
sub getGpfsStat {

	# To record the snapshot (hash of hashes)
	my %snapshot = (
		"gbytesin" => 0.0,
		"gbytesout" => 0.0,
		"gopens" => 0.0,
		"gcloses" => 0.0,
		"greads" => 0.0,
		"gwrites" => 0.0,
		"grdir" => 0.0,
		"giupdate" => 0.0
	);

	my @volumes = ();

	my $cmd = "echo fs_io_s | " . MMPMON_PATH . " -p -s";
#	my $cmd = MMPMON_PATH . " -p -s <<EOF
#fs_io_s
#EOF"
#	my $cmd = MMPMON_PATH . " ./mmpmon.dat";

	# Call the command line and get outputs of mmpmon
	#open(my $fh, "-|", $cmd) or return {};
	my @outputs = `$cmd`;
	if ($? >> 8 != 0) {
		return {};	
	}

	# Parse each line
	foreach (@outputs) {
		# Trim the string
		my $line = trim($_);

		# Skip empty line
		next if ("" eq $line);

		# Split the current line
		my @tokens = split(" ", $line);
		next if (@tokens < 1);
		
		# Put the split colums into a hash
		my %values = ();
		for (my $idx = STARTING_IDX_METRICS; $idx < @tokens; $idx += 2) {
			$values{$tokens[$idx]} = $tokens[$idx + 1];
		}

		my $gpfsName = $tokens[IDX_GPFS_NAME];
		next if (!($gVolumeSet{$gpfsName}));

		# Parse desired indexes
		my $gbytesin = $values{"_br_"} / (1024 * 1024);
		my $gbytesout = $values{"_bw_"} / (1024 * 1024);
		$snapshot{"gbytesin"} = $snapshot{"gbytesin"} + $gbytesin;
		$snapshot{"gbytesout"} = $snapshot{"gbytesout"} + $gbytesout;
		$snapshot{"gopens"} = $snapshot{"gopens"} + $values{"_oc_"};
		$snapshot{"gcloses"} = $snapshot{"gcloses"} + $values{"_cc_"};
		$snapshot{"greads"} = $snapshot{"greads"} + $values{"_rdc_"};
		$snapshot{"gwrites"} = $snapshot{"gwrites"} + $values{"_wc_"};
		$snapshot{"grdir"} = $snapshot{"grdir"} + $values{"_dir_"};
		$snapshot{"giupdate"} = $snapshot{"giupdate"} + $values{"_iu_"};
#		print  "gbytesin: " . $gbytesin . "\n";
		# Volume level indexes
		$snapshot{"gbytesin_$gpfsName"} = $gbytesin;
		$snapshot{"gbytesout_$gpfsName"} = $gbytesout;

		push(@volumes, $gpfsName);
	}

	return (\%snapshot, \@volumes);
}

#--------------------------------------------------------------------
# Calculate delta
#--------------------------------------------------------------------
sub calcDelta {
	my ($deltaArray, $snapshot, $lastSnapshot, $samplingTime, $lastSamplingTime) = @_;

	my %deltaMap = ();
	for (keys %$snapshot) {
		my $preValue = $lastSnapshot->{$_};	
		my $value = $snapshot->{$_};	
		$deltaMap{$_} = $value - $preValue;
	}
	# Record down the sampling time and sampling interval for the delta value
	$deltaMap{SAMPLING_TIME} = $samplingTime;
	$deltaMap{SAMPLING_INTERVAL} = ($samplingTime - $lastSamplingTime);

	# Push the deltaMap at the end of the array
	push(@{$deltaArray}, \%deltaMap);

	# Remove undesired delta map from the array
	while ($#{$deltaArray} > 0) {
		my $firstSamplingTime = $deltaArray->[0]->{SAMPLING_TIME};

		# If the time period stored in the array is greater than FLOATING_AVG_INTERVAL,
		# shift items at the begining of the array
		if ($samplingTime - $firstSamplingTime < MAX_SAMPLING_INTERVAL) {
			last;
		}
		shift(@{$deltaArray});
	}
}

#--------------------------------------------------------------------
# Calculate total value
#--------------------------------------------------------------------
sub calcTotal {
	my ($deltaArray, $resName) = @_;

	my $total = 0;	
	foreach (@$deltaArray) {
		$total += $_->{$resName};
	}

	return $total;
}

#--------------------------------------------------------------------
# Calculate maximum value
#--------------------------------------------------------------------
sub calcMax {
	my ($deltaArray, $resName) = @_;
	my $max = 0;	
	my $interval = 0;	
	my $value;
	foreach (@$deltaArray) {
		$value = $_->{$resName};
		if ($max < $value) {
			$max = $value;
			$interval = $_->{SAMPLING_INTERVAL};
		}
	}

	return $interval == 0 ? 0 : $max / $interval;
}
#--------------------------------------------------------------------
# Check environment variables
#--------------------------------------------------------------------
sub checkResourceDefined {
	my ($resources, $resName) = @_;

    my @resArray = split(" ",$resources);

        foreach (@resArray) {
		if ($_ eq $resName) {
		     return 0;
		}
	}

	return 1;

}


#--------------------------------------------------------------------
# Entry of the elim
#--------------------------------------------------------------------
sub _main {
        if ( ! -e MMPMON_PATH ) {
	        exit $ENV{'ELIM_ABORT_VALUE'};
	}

	my @deltaArray = (); 
	my $lastSnapshot = {};
	my $lastSamplingTime = 0;
	my $samplingTimeAdjustment = 0;

	my @resNames = (
        "gstatus",
		"gbytesin",
		"gbytesout",
		"gopens",
		"gcloses",
		"greads",
		"gwrites",
		"grdir",
		"giupdate"
	);	

	# Convert the VOLUMES list to a hash table
    foreach (@{+VOLUMES}) {
		$gVolumeSet{$_} = 1;
    }

    # check all the resources names
    my $resources = $ENV{'LSF_RESOURCES'};

    	if ($resources) {
	        foreach (@resNames) {
		        if( checkResourceDefined($resources ,$_) == 1) {
                    exit (0);
                } 
	       }
	    }    


	while (1) {
		# Get the current microsecond
		my ($seconds, $fraction) = gettimeofday();
		my $startTime = $seconds * 1000000 + $fraction;

		# Get the current snapshot
		my ($snapshot, $volumes) = getGpfsStat();
		my $resResult = "";
		my $numRes = 0;

		if (keys %$snapshot > 0) {
			# gstatus
			$resResult = "gstatus OK";
			$numRes += 1;

			if ($lastSamplingTime > 0) {
				# Calculate delta and put the result into the deltaArray
				calcDelta(\@deltaArray, $snapshot, $lastSnapshot, $startTime / 1000000, $lastSamplingTime / 1000000);

				# Make the current snapshot/sampling time the last snapshot/sampling time
				$lastSnapshot = $snapshot;
				$samplingTimeAdjustment = $startTime - $lastSamplingTime - CHECK_INTERVAL * 1000000;
			}
			$lastSnapshot = $snapshot;
			$lastSamplingTime = $startTime;

			if ($#deltaArray >= 0) {
				my $resFormatter = "%s %s %." . DECIMAL_DIGITS . "f";

				# time period
				my $timePeriod = calcTotal(\@deltaArray, SAMPLING_INTERVAL);

				# gbytesin
				my $gbytesin = calcTotal(\@deltaArray, "gbytesin");
				$resResult = sprintf($resFormatter, $resResult, "gbytesin", $gbytesin / $timePeriod);
                                
				# gmbytein
				my $gmbytesin = calcMax(\@deltaArray, "gbytesin");
				$resResult = sprintf($resFormatter, $resResult, "gmbytesin", $gmbytesin);

				# gbyteout
				my $gbytesout = calcTotal(\@deltaArray, "gbytesout");
				$resResult = sprintf($resFormatter, $resResult, "gbytesout", $gbytesout / $timePeriod);

				# gmbyteout
				my $gmbytesout = calcMax(\@deltaArray, "gbytesout");
				$resResult = sprintf($resFormatter, $resResult, "gmbytesout", $gmbytesout);

				# gopens
				my $gopens = calcTotal(\@deltaArray, "gopens");
				$resResult = sprintf($resFormatter, $resResult, "gopens", $gopens / $timePeriod);

				# gcloses
				my $gcloses = calcTotal(\@deltaArray, "gcloses");
				$resResult = sprintf($resFormatter, $resResult, "gcloses", $gcloses / $timePeriod);

				# greads
				my $greads = calcTotal(\@deltaArray, "greads");
				$resResult = sprintf($resFormatter, $resResult, "greads", $greads / $timePeriod);

				# gwrites
				my $gwrites = calcTotal(\@deltaArray, "gwrites");
				$resResult = sprintf($resFormatter, $resResult, "gwrites", $gwrites / $timePeriod);
				
				# grdir
				my $grdir = calcTotal(\@deltaArray, "grdir");
				$resResult = sprintf($resFormatter, $resResult, "grdir", $grdir / $timePeriod);

				# giupdate
				my $giupdate = calcTotal(\@deltaArray, "giupdate");
				$resResult = sprintf($resFormatter, $resResult, "giupdate", $giupdate / $timePeriod);

				$numRes += 10;

				foreach (@$volumes) {
					my $gpfsName = $_;
					my $totalValue = calcTotal(\@deltaArray, "gbytesin_$gpfsName");
					$resResult = sprintf($resFormatter, $resResult, "gbytesin_$gpfsName", $totalValue / $timePeriod);

					my $maxValue = calcMax(\@deltaArray, "gbytesin_$gpfsName");
					$resResult = sprintf($resFormatter, $resResult, "gmbytesin_$gpfsName", $maxValue);

					$totalValue = calcTotal(\@deltaArray, "gbytesout_$gpfsName");
					$resResult = sprintf($resFormatter, $resResult, "gbytesout_$gpfsName", $totalValue / $timePeriod);

					$maxValue = calcMax(\@deltaArray, "gbytesout_$gpfsName");
					$resResult = sprintf($resFormatter, $resResult, "gmbytesout_$gpfsName", $maxValue);

					$numRes += 4;
				}
			}
		}
		else {
			$resResult = "gstatus -";
			$numRes = 1;
		}

		# Concat the gstatus
		$resResult = "$numRes $resResult";

		# Output the resource string to stdout
		print $resResult;
		print "\n";

		# Get the current microsecond
		($seconds, $fraction) = gettimeofday();
		my $endTime = $seconds * 1000000 + $fraction;

		my $timeToSleep = CHECK_INTERVAL * 1000000 - ($endTime - $startTime) - $samplingTimeAdjustment;
		if ($timeToSleep > 0) {
			usleep($timeToSleep);
		}
	}
}

# Set an auto-flush for both STDOUT and STDERR
select(STDERR);
$| = 1;
select(STDOUT);
$| = 1;

# Entering the main entry
_main();

